### 一、安装组件仓库
    **不需要按照私有仓库的情况下是不需要设置npm源的**
    第一步:全局安装nrm: npm i -g nrm 
    第二步: 设置一个源为http://192.168.1.233:8081/nexus/repository/group-npm/ 
    命令是nrm add pkuse http://192.168.1.233:8081/nexus/repository/group-npm/
    使用私有仓库地址的方法： nrm use pkuse
    第三步: 在项目中安装ui控件包: npm i @pkuse/hr-ui -S

```javascript
import pkuseHrUi from '@pkuse/hr-ui'
import '@pkuse/hr-ui/lib/theme-chalk/index.css'
Vue.use(pkuseHrUi)
```
### 二、关于axios请求的方式说明
    axios的封装包括post,get,file 类型的请求方式
    并且提供默认加密方式如若传参默认为：
        - 对象形式则全部加密
        - 函数形式则可以通过回调和方式拿到加密方法对参数逐个加密从而返回加密后的结果


第一步、在src/api中index.js 定义如下：
```javascript
import { reqMethods } from 'common/utils/request'
// import { pathMap } from './reqPathConfig' 如果映射关系太多可以单独起文件进行定义
/*
 * 在映射中 key值为请求名，value为请求路径
 * 在映射名中分别以不同类型的请求方式开头 （必须）
 * get_: get 的请求方式
 * post_：post 的请求方式
 * file：file 的请求方式
*/
const pathMap = {
  get_test_req: '/baidu/dd', // get请求
  post_test_req: '/baidu/dd', // post请求
  post_test_req1: {  // 自定义请求路径和头部信息以及请求方法
    url: '',
    headers: {
    'Content-Type': 'application/json;charset=UTF-8'
    },
    method: 'post',
    paramType: 'params' // 选择data或者params 类型参数字段
  } 
}


// 将映射关系放置在请求方法中并且拿到设置请求映射后的请求方法
const reqExample = reqMethods({
    baseUrl: '', // 设置请求基础url路径
    pathMap
}) // 获取请求实例
export const req = reqExample.req // 便于在js文件中使用
export default {
  install: (Vue) => {
    Vue.use(reqExample) // 注册的方式便于在
  }
}
```
第二步：在main.js中引入并且挂载在vue上
```javascript
import api from '@/api'
Vue.use(api)
```
第三步：在vue或者js文件中使用
- xxx.vue
```vue
<script>
// 需要使用第三种情况加密请求时需要引入
import { encryptedData } from 'common/utils/JSEncrypt'
export default {
  mounted() {
    // 1. 传参为对象参数时默认全部加密
    this.$http('get_test_req', {
       b: '1',
       c: '3'
    }).then(res => {
      console.log(res)
    })
    // 2. 传参以回调函数返回加密方法对参数进行逐个加密方法
    this.$http('get_test_req', (encrypted) => {
      return {
        b: encrypted('1'),
        c: '3'
      }
    }).then(res => {
      console.log(res)
    })
    // 3. 对于复杂参数进行逐个加密
    let obj = {
        b: encryptedData('1'),
        c: '3'
    }
    // 注意，在使用这种方式时需要传递第三个参数为true代表不默认加密
    this.$http('get_test_req', obj, true).then(res => {
      console.log(res)
    })
    // 4. 自定义请求方式
    this.$http({
      url: '',
      headers: {
      'Content-Type': 'application/json;charset=UTF-8'
      },
      method: 'post',
      paramType: 'params' // 选择data或者params 类型参数字段
    }, obj, true || false).then(res => {
      console.log(res)
    })
  }
}
</script>
```

- xxx.js 在JavaScript中使用
```javascript
// 需要使用第三种情况加密请求时需要引入
import { req } from '@/api'
import { encryptedData } from 'common/utils/JSEncrypt'
// 1. 传参为对象参数时默认全部加密
req('get_test_req', {
   b: '1',
   c: '3'
}).then(res => {
  console.log(res)
})
// 2. 传参以回调函数返回加密方法对参数进行逐个加密方法
req('get_test_req', (encrypted) => {
  return {
    b: encrypted('1'),
    c: '3'
  }
}).then(res => {
  console.log(res)
})
// 3. 对于复杂参数进行逐个加密
let obj = {
    b: encryptedData('1'),
    c: '3'
}
// 注意，在使用这种方式时需要传递第三个参数为true代表不默认加密
req('get_test_req', obj, true).then(res => {
  console.log(res)
})

// 4. 自定义请求方式
req({
  url: '',
  headers: {
  'Content-Type': 'application/json;charset=UTF-8'
  },
  method: 'post',
  paramType: 'params' // 选择data或者params 类型参数字段
}, obj, true || false).then(res => {
  console.log(res)
})
```

### 三、全局用户登录信息调用

> 登录后的用户信息存放在vuex的global 模块中

- 在xxx.vue文件中

```javascript
<template>
    <div></div>
</template>

<script>
import { mapState } from 'vuex'
export default {
  computed: {
    // 通过global获取user的信息
    ...mapState('global', {
      userInfo: state => state.userInfo
    })
  },
  created () {
  	console.log(this.userInfo)
  }
}
</script>

<style>
</style>

```

### 四、全局用户按钮级别权限控制

> 权限配置，根据用户登录之后返回的用户信息 roles 取到用户拥有的
> 首先需要在main.js 中 导入 全局指令   
> // 全局指令 v-permission  
>  import permission from 'common/utils/directivers/index'
> Vue.use(permission)
- 在xxx.vue文件中

```vue
<template>
    <div> <a-button v-permission="'user:add'">新增</a-button> </div>
</template>

<script>
export default {
}
</script>

<style>
</style>

```
> v-permission 中的值可以是菜单的功能标识，和菜单资源（按钮的资源编码）
> 支持传值 为单个字符串 v-permission="'user:add'" 
> 或者以逗号隔开的字符串v-permission="'user:add,limit'"
> 或者值字符串数组 v-permission="['user:add', 'limit']"
>
> 功能标识和资源编码需要全局唯一
>
> ![路由权限](./image/permission-1.png)
>
> ![路由权限](./image/permission-2.png)


> method: checkPermission(roles)
>
> 权限配置，根据用户登录之后返回的用户信息 roles 取到用户拥有的
>
> 同：v-permission 指令

```vue
<template>
  <div class="splicing">
    <div class="splicing_main" v-if='checkPermission(["e12d7ec8a19e43b58e678445a75101371"])'>
        
    </div>
  </div>
</template>
<script>
import checkPermission from 'common/utils/checkPermission'
export default {
	methods: { checkPermission }
}
</script>
```



### 五、系统路由动态化

> 用户登录之后，由接口 /author/SAuFunction/lisFunctionVOTree 请求到当前登录用户拥有的路由权限，然后渲染到页面。
> 首先需要在main.js 中的 
```
store.dispatch('global/login', (encrypted) => {
    return {
      userName: 'admin',
      passWord: encrypted('admin'),
      verifyCode: ''
    }
  }).then(res => {
    // 在此处添加一行代码，获取并分发路由。
    store.dispatch('global/dyrouters').then(res => {
      const subMenu = res.data.find(item => item.path === '/ss') // 此处的ss 代表ss子系统其他子系统各自配相应的参数 
      const indexMenu = res.data.find(item => item.name === '首页')
      store.commit('global/SET_MENU', [indexMenu, subMenu])
    })
    render()
  })
```
> 在系统中添加路由的功能模块注册里添加菜单
>![功能模块注册](.\image\功能模块注册.png)
>![功能模块注册](.\image\功能模块注册2.png)
>注意！！！  
>访问路径就是功能的菜单地址 必填 规则是 / 开头的，以系统进行区分的路由地址，改地址是必须唯一。比如系统管理的 是 /sym , 其子路由就是 以/sym开头的路由地址。 
>需要和路由文件中的名称保持一致
>![路由](./image/ly-1.png)
> 
>图标路径是 common/lib/fontIcon/demo_index.html 里的字体图标 类名
>比如 系统管理 就是 iconganbujiandu 前提是   common/lib/fontIcon/demo_index.html 文件里面必须有该图标。
>![菜单字体图标](./image/菜单字体图标使用.png)
>```
>在 portal 系统里做的处理就是登录之后请求接口 
>
>/author/SAuFunction/lisFunctionVOTree
>
>在 portal 的 pwdLogin.vue 的 login 方法里 
>
>this.$store.dispatch('global/login', (encrypted) => {
>        return {
>          userName: userName,
>          passWord: encrypted(userPwd),
>          verifyCode: ''
>        }
>      }).then(res => {
>        if (res.code === 200) {
>          const global = this.$store.state.global
>          store.setGlobalState({
>            token: global.token,
>            userInfo: global.userInfo
>          })
>          this.$store.dispatch('global/dyrouters').then(res => {
>            this.$store.commit('global/SET_MENU', res.data)
>          })
>          history.pushState(null, '/sym', '/sym')
>        } else {
>          this.openNotificationWithIcon('error', '登录失败', res.message)
>        }
>      })
>```

